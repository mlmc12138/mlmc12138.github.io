{"posts":[{"title":"杂记","content":" 分享我喜欢的歌手 房东的猫 浪漫才子-吴佩玲 人间理想-王心怡 ","link":"https://mlmc12138.github.io/post/za-ji/"},{"title":"二分查找","content":"二分查找是非常经典的算法；虽然不复杂，但是有很多细节在里面；要做到看到能使用二分的题立刻想出思路 核心代码 var search = function(nums, target) { let sum = 0 let left = 0 let right = nums.length-1 while(left&lt;=right) { let mid = (left +(right-left))&gt;&gt;1 if(nums[mid]==target) { return mid } else if(nums[mid&gt;target]) { right = mid - 1 } else if(nums[mid]&lt;target) { left = mid + 1 } } }; 值得注意的点就是 while循环里的 条件是 left &lt; right 还是 left &lt;= right；以及 mid是+1还是-1的问题 为什么 while 循环的条件中是 &lt;=，而不是 &lt;？ 因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。 我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。 while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。 while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [2, 2]，这时候区非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。 为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？ 当发现索引 mid 不是要找的 target 时，下一步应该去搜索 [left, mid-1] 或者 [mid+1, right] ","link":"https://mlmc12138.github.io/post/er-fen-cha-zhao/"},{"title":"单链表题目","content":"合并两个有序单链表： ​ 题目链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/ ​ 思路：比较两个链表的值，将值较小的加入到结果链表中 ​ 代码： var mergeTwoLists = function(list1, list2) { if(list1===null) { return list2 } if(list2===null) { return list1 } if(list1.val&lt;list2.val) { list1.next = mergeTwoLists(list1.next,list2) return list1 } else { list2.next = mergeTwoLists(list1,list2.next) return list2 } }; 环形链表 ​ 题目地址：https://leetcode-cn.com/problems/linked-list-cycle/ ​ 思路：通过快慢指针进行判断，快指针一次走两步，慢指针一次走一步，若链表中存在环，则两指针一定会有重合的时候 ​ 代码： var hasCycle = function(head) { let left = head let right = head while(right!=null&amp;&amp;right.next!=null) { left = left.next right = right.next.next if(left==right) { return true } } return false }; 链表的中间节点 ​ 题目地址： https://leetcode-cn.com/problems/middle-of-the-linked-list/ ​ 思路： 通过快慢指针进行判断，指针运动方式 慢指针一次一步 快指针一次两步 这样当快指针到达尾部时，慢指针所在的位置就是链表的中点 ​ 代码 var middleNode = function(head) { let slow = head let fast = head while(fast&amp;&amp;fast.next) { fast = fast.next.next slow = slow.next } return slow }; 删除单链表的倒数第k个元素 ​ 题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ ​ 思路： 也是通过快慢指针；要删除倒数第k个元素即要从前向后走 n-k 步 （n为链表长度） 让两指针相距k，当快指针走到最后时，慢指针的next即为倒数第k个元素 ​ 代码： var removeNthFromEnd = function (head, n) { var left = head var right = head while(n&gt;0) { right = right.next n-- } if(!right) return head.next while(right&amp;&amp;right.next) { left = left.next right = right.next } left.next = left.next.next return head }; 这些都是比较经典的单链表相关的问题，大部分题目都是使用双指针去解决的；在做题时一定要灵活运用双指针 ","link":"https://mlmc12138.github.io/post/dan-lian-biao-ti-mu/"}]}