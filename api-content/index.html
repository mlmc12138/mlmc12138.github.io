{"posts":[{"title":"js 原型对象与原型链","content":"基本概念 每个对象都有自己的原型对象，它可以使用其原型链上的所有属性和方法。 获取原型的几种方式 通过对象的 __proto__ 获取 let cat = { name: &quot;喵喵&quot; } // 在 cat 的原型对象上添加一个 eat 方法 cat.__proto__.eat = function() { console.log(&quot;吃鱼&quot;) } cat.eat() // 打印出吃鱼 说明 cat 使用了其原型上的方法 通过构造函数的 prototype 获取function Dog(name,age) { this.name = name this.age = age } // 在 Dog 的原型对象上添加一个 eat 方法 Dog.prototype.eat = ()=&gt; { console.log(&quot;吃骨头&quot;); } let dog = new Dog(&quot;大黄&quot;,2) dog.eat() //打印出吃骨头 原型对象的应用 如果我们执行以下代码 let date = new Date() console.log(date) 此时会打印下图中第一行的结果 如果我们想要打印第二行 这样格式的时间呢； 此时我们就可以给 Date的原型对象添加一个方法 来将输出格式化，具体代码如下 let data = new Date() Date.prototype.formate = function() { let year = this.getFullYear() let month = this.getMonth() let date = this.getDate() return `${year}年${month}月${date}日` } console.log(data.formate()); 此时就能输出 第二行格式的时间了 原型对象类与继承 类获取原型的方式与构造函数一样，都是通过 prototype 属性去获取 class Cat { constructor(name,age) { this.name = name this.age = age } } Cat.prototype.eat = function() { console.log(&quot;吃鱼&quot;); } let cat = new Cat(&quot;喵喵&quot;,2) console.log(cat.name); cat.eat() // 输出吃鱼 类的继承实例 实现 管理员与普通用户 管理员拥有普通用户有的所有属性和功能 class User { constructor(name,password) { this.name = name this.password = password } login() { console.log(&quot;登录&quot;); } } // 继承 User 类 获取 其中的属性与方法 class Admin extends User{ removeUser() { console.log(&quot;删除&quot;); } } let admin = new Admin() // 此时 admin 就可以使用 User 中的 login 方法 admin.login() 原型继承与原型链 用ES6的 class 我们实现了上述功能，如果不用ES6我们要如何实现上述功能呢？ 我们可以通过改变构造方法原型对象的指向 在这个例子中，我们就将 Admin 的原型对象 指向 User 这样的话，Admin就拥有User所有的属性和方法了； 具体代码如下 function User(name,password) { this.name = name this.password = password this.login = function () { console.log(&quot;登录&quot;) } } function Admin() { this.removeUser = function () { console.log(&quot;删除用户&quot;); } } // 基于原型的继承 通过将对象的原型指向要继承的对象 Admin.prototype = new User() let admin = new Admin() admin.login() 那么什么是原型链呢？ 每个对象都有自己的原型对象，它的原型对象也有自己的原型对象，如下图所示 Tips：Object.prototype 是所有对象的原型对象 ","link":"https://mlmc12138.github.io/post/js-yuan-xing-dui-xiang-yu-yuan-xing-lian/"},{"title":"Vue项目打包后页面空白问题","content":"第一种情况 资源加载失败 报错如下 这个问题是由于路径的问题，我们可以在项目下新建一个 vue.config.js 文件，在里面我们输入如下代码 module.exports = { publicPath:'./' } 再重新进行打包就可以了，这时候的资源都能够加载成功了 第二种情况 无报错 此时我们可能在使用路由时，为了美观将其mode改为了history模式，此时我们需要将其改为hash模式才能正常显示，这时候我们要找到 src/router 下的index.ts/index.js文件将 createWebHistory改为 createWebHashHistory即可 ","link":"https://mlmc12138.github.io/post/vue-xiang-mu-da-bao-hou-ye-mian-kong-bai-wen-ti/"},{"title":"防抖与节流","content":" 防抖 概念 用户操作触发事件频繁，只要最后一次的操作 使用场景 &lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; let inp = document.querySelector(&quot;input&quot;) inp.oninput = function() { console.log(this.value); } &lt;/script&gt; &lt;/body&gt; 当我们在输入框中输入一个“前”字时，以上代码在执行时，会出现如下图所示的情况 仅输入一个“前”字函数就执行了五次。那么当我们输入的字符串很长时，函数执行的次数也会变得很多；如果我们要发送请求的话，请求会变得非常频繁，导致性能下降； 如何把函数执行的次数降低，就是防抖的使用场景 第一种方式-非立即执行 当用户进行输入时，不会立即执行函数，而是等待 n 秒后再去执行函数，如果在此期间用户有新的输入，则重新计算 n； let inp = document.querySelector(&quot;input&quot;) let timer = null inp.oninput = function () { if (timer !== null) { clearTimeout(timer) } timer = setTimeout(() =&gt; { console.log(this.value); }, 500) } 第一种方式的优化 原理一样，只不过优化后的代码更容易维护，并且没有又创建一个全局变量 inp.oninput = debouce(function(){ console.log(this.value); },500) function debouce(fn, delayTime) { let timer = null return function () { if (timer !== null) { clearTimeout(timer) } timer = setTimeout(() =&gt; { fn.call(this) }, delayTime) } } 第二种方式-立即执行 用户第一次输入时立刻触发，然后n秒后不触发该事件才能继续执行函数 function debouce(fn, delayTime) { let timer = null let flag = true return function () { clearTimeout(timer) if(flag) { fn.call(this) flag = false } timer = setTimeout(() =&gt; { flag = true }, delayTime) } } 结合版本 function debounce_merge(fn,delayTime = 500,isImmediate = false){ let timer= null; let flag = true; if(isImmediate){ return function(){ clearTimeout(timer); if(flag){ fn.call(this); flag = false } timer = setTimeout(() =&gt; { flag = true},delayTime) } } return function(){ clearTimeout(timerId); timer = setTimeout(() =&gt; { fn.call(this) },delayTime) } } 节流 概念 用户触发事件频繁，减少事件执行的次数；如触发1000次，使用节流使其触发次数减少到10 使用场景 &lt;body&gt; &lt;script&gt; window.onscroll = ()=&gt; { console.log(&quot;hello world!&quot;); } // &lt;/script&gt; &lt;/body&gt; 当我们滚动上图代码展示的页面时 会发生这样的效果 稍微滚动，函数就会被执行很多次；我们想让其执行次数减少到我们想让它执行的次数，这时候我们就要用到节流了 第一种方法 - 非立即执行 通过定时器限定多久执行一次 let flag = true window.onscroll = ()=&gt; { if(flag) { setTimeout(()=&gt; { console.log(&quot;Hello world&quot;); flag = true },500) } flag = false } 函数优化 优化方法与防抖函数的优化相同 window.onscroll = throttle(function(){ console.log(this.value); },500) function throttle(fn, delayTime) { let flag = true return function () { if (flag) { setTimeout(() =&gt; { fn() flag = true }, delayTime) } flag = false } } 第二种方法 - 立即执行 function throttle(fn, delayTime) { let flag = true return function () { if (flag) { setTimeout(() =&gt; { fn() flag = true }, delayTime) } flag = false } } 第三种方法 - 时间戳版本 创建时间戳，在时间戳内，函数只执行一次 window.onscroll = throttle(function(){ console.log(&quot;Hello world!&quot;); },1000) function throttle(fn, delayTime) { let pre = 0 return function(){ let now = Date.now() if(now-pre&gt;delayTime) { fn.call(this) pre = now } } } 总结 相同点 防抖与节流都是为了防止函数在短时间内被频繁的触发 不同点 防抖函数只执行最后一次的操作，类似游戏中的回城，在回城期间，进行操作会打断回城 节流类似将多个操作合并为一个，类似于游戏中的技能释放，释放后技能会进入CD，CD完成后才能再次进行施法 ","link":"https://mlmc12138.github.io/post/fang-dou-yu-jie-liu/"},{"title":"杂记","content":" 分享我喜欢的歌手 房东的猫 浪漫才子-吴佩玲 人间理想-王心怡 ","link":"https://mlmc12138.github.io/post/za-ji/"},{"title":"二分查找","content":"二分查找是非常经典的算法；虽然不复杂，但是有很多细节在里面；要做到看到能使用二分的题立刻想出思路 核心代码 var search = function(nums, target) { let sum = 0 let left = 0 let right = nums.length-1 while(left&lt;=right) { let mid = (left +(right-left))&gt;&gt;1 if(nums[mid]==target) { return mid } else if(nums[mid&gt;target]) { right = mid - 1 } else if(nums[mid]&lt;target) { left = mid + 1 } } }; 值得注意的点就是 while循环里的 条件是 left &lt; right 还是 left &lt;= right；以及 mid是+1还是-1的问题 为什么 while 循环的条件中是 &lt;=，而不是 &lt;？ 因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。 我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。 while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。 while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [2, 2]，这时候区非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。 为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？ 当发现索引 mid 不是要找的 target 时，下一步应该去搜索 [left, mid-1] 或者 [mid+1, right] ","link":"https://mlmc12138.github.io/post/er-fen-cha-zhao/"},{"title":"单链表题目","content":"合并两个有序单链表： ​ 题目链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/ ​ 思路：比较两个链表的值，将值较小的加入到结果链表中 ​ 代码： var mergeTwoLists = function(list1, list2) { if(list1===null) { return list2 } if(list2===null) { return list1 } if(list1.val&lt;list2.val) { list1.next = mergeTwoLists(list1.next,list2) return list1 } else { list2.next = mergeTwoLists(list1,list2.next) return list2 } }; 环形链表 ​ 题目地址：https://leetcode-cn.com/problems/linked-list-cycle/ ​ 思路：通过快慢指针进行判断，快指针一次走两步，慢指针一次走一步，若链表中存在环，则两指针一定会有重合的时候 ​ 代码： var hasCycle = function(head) { let left = head let right = head while(right!=null&amp;&amp;right.next!=null) { left = left.next right = right.next.next if(left==right) { return true } } return false }; 链表的中间节点 ​ 题目地址： https://leetcode-cn.com/problems/middle-of-the-linked-list/ ​ 思路： 通过快慢指针进行判断，指针运动方式 慢指针一次一步 快指针一次两步 这样当快指针到达尾部时，慢指针所在的位置就是链表的中点 ​ 代码 var middleNode = function(head) { let slow = head let fast = head while(fast&amp;&amp;fast.next) { fast = fast.next.next slow = slow.next } return slow }; 删除单链表的倒数第k个元素 ​ 题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ ​ 思路： 也是通过快慢指针；要删除倒数第k个元素即要从前向后走 n-k 步 （n为链表长度） 让两指针相距k，当快指针走到最后时，慢指针的next即为倒数第k个元素 ​ 代码： var removeNthFromEnd = function (head, n) { var left = head var right = head while(n&gt;0) { right = right.next n-- } if(!right) return head.next while(right&amp;&amp;right.next) { left = left.next right = right.next } left.next = left.next.next return head }; 这些都是比较经典的单链表相关的问题，大部分题目都是使用双指针去解决的；在做题时一定要灵活运用双指针 ","link":"https://mlmc12138.github.io/post/dan-lian-biao-ti-mu/"}]}