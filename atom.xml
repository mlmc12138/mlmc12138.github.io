<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mlmc12138.github.io</id>
    <title>Gridea</title>
    <updated>2022-02-15T11:18:26.776Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mlmc12138.github.io"/>
    <link rel="self" href="https://mlmc12138.github.io/atom.xml"/>
    <subtitle>叶凡的主页</subtitle>
    <logo>https://mlmc12138.github.io/images/avatar.png</logo>
    <icon>https://mlmc12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Vue项目打包后页面空白问题]]></title>
        <id>https://mlmc12138.github.io/post/vue-xiang-mu-da-bao-hou-ye-mian-kong-bai-wen-ti/</id>
        <link href="https://mlmc12138.github.io/post/vue-xiang-mu-da-bao-hou-ye-mian-kong-bai-wen-ti/">
        </link>
        <updated>2022-02-15T02:47:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一种情况-资源加载失败">第一种情况 资源加载失败</h1>
<p>报错如下<br>
<img src="https://mlmc12138.github.io/post-images/1644893370600.png" alt="" loading="lazy"><br>
这个问题是由于路径的问题，我们可以在项目下新建一个  <code>vue.config.js</code>  文件，在里面我们输入如下代码</p>
<pre><code class="language-js">module.exports = {
  publicPath:'./'
}
</code></pre>
<p>再重新进行打包就可以了，这时候的资源都能够加载成功了</p>
<h1 id="第二种情况-无报错">第二种情况 无报错</h1>
<p>此时我们可能在使用路由时，为了美观将其<code>mode</code>改为了history模式，此时我们需要将其改为<code>hash</code>模式才能正常显示，这时候我们要找到 <code>src/router</code> 下的<code>index.ts/index.js</code>文件将 <code>createWebHistory</code>改为 <code>createWebHashHistory</code>即可<br>
<img src="https://mlmc12138.github.io/post-images/1644894139898.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://mlmc12138.github.io/post-images/1644894146987.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://mlmc12138.github.io/post-images/1644894223118.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://mlmc12138.github.io/post-images/1644894234700.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防抖与节流]]></title>
        <id>https://mlmc12138.github.io/post/fang-dou-yu-jie-liu/</id>
        <link href="https://mlmc12138.github.io/post/fang-dou-yu-jie-liu/">
        </link>
        <updated>2022-02-12T06:53:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="防抖">防抖</h1>
<h3 id="概念">概念</h3>
<p>用户操作触发事件频繁，只要最后一次的操作</p>
<h3 id="使用场景">使用场景</h3>
<pre><code class="language-html">&lt;body&gt;
  &lt;input type=&quot;text&quot;&gt;
  &lt;script&gt;
    let inp = document.querySelector(&quot;input&quot;)
    inp.oninput = function() {
      console.log(this.value);
    }
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>当我们在输入框中输入一个“前”字时，以上代码在执行时，会出现如下图所示的情况<br>
<img src="https://mlmc12138.github.io/post-images/1644649282426.png" alt="" loading="lazy"><br>
仅输入一个“前”字函数就执行了五次。那么当我们输入的字符串很长时，函数执行的次数也会变得很多；如果我们要发送请求的话，请求会变得非常频繁，导致性能下降；</p>
<!-- more -->
<p>如何把函数执行的次数降低，就是防抖的使用场景</p>
<h3 id="第一种方式-非立即执行">第一种方式-非立即执行</h3>
<p>当用户进行输入时，不会立即执行函数，而是等待 n 秒后再去执行函数，如果在此期间用户有新的输入，则重新计算 n；</p>
<pre><code class="language-js">    let inp = document.querySelector(&quot;input&quot;)
    let timer = null
    inp.oninput = function () {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(() =&gt; {
        console.log(this.value);
      }, 500)
    }
</code></pre>
<h3 id="第一种方式的优化">第一种方式的优化</h3>
<p>原理一样，只不过优化后的代码更容易维护，并且没有又创建一个全局变量</p>
<pre><code class="language-js">    inp.oninput = debouce(function(){
      console.log(this.value);
    },500)
    function debouce(fn, delayTime) {
       let timer = null
       return function () {
        if (timer !== null) {
          clearTimeout(timer)
        }
        timer = setTimeout(() =&gt; {
           fn.call(this)
        }, delayTime)
      }
    } 
</code></pre>
<h3 id="第二种方式-立即执行">第二种方式-立即执行</h3>
<p>用户第一次输入时立刻触发，然后n秒后不触发该事件才能继续执行函数</p>
<pre><code class="language-js">     function debouce(fn, delayTime) {
      let timer = null
      let flag = true
      return function () {
        clearTimeout(timer)
        if(flag) {
          fn.call(this)
          flag = false
        }
        timer = setTimeout(() =&gt; {
          flag = true
        }, delayTime)
      }
    } 
</code></pre>
<h3 id="结合版本">结合版本</h3>
<pre><code class="language-js">function debounce_merge(fn,delayTime = 500,isImmediate = false){
  let timer= null;
  let flag = true;
  if(isImmediate){
    return function(){
      clearTimeout(timer);
      if(flag){
        fn.call(this);
        flag = false
        }
      timer = setTimeout(() =&gt; { flag = true},delayTime)
    }
  }
  return function(){
    clearTimeout(timerId);
    timer = setTimeout(() =&gt; {
      fn.call(this)
    },delayTime)
  }
}
</code></pre>
<h1 id="节流">节流</h1>
<h3 id="概念-2">概念</h3>
<p>用户触发事件频繁，减少事件执行的次数；如触发1000次，使用节流使其触发次数减少到10</p>
<h3 id="使用场景-2">使用场景</h3>
<pre><code class="language-html">&lt;body&gt;
  &lt;script&gt;
    window.onscroll = ()=&gt; {
      console.log(&quot;hello world!&quot;);
    }
    // 
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>当我们滚动上图代码展示的页面时 会发生这样的效果<br>
<img src="https://mlmc12138.github.io/post-images/1644657207757.png" alt="" loading="lazy"><br>
稍微滚动，函数就会被执行很多次；我们想让其执行次数减少到我们想让它执行的次数，这时候我们就要用到节流了</p>
<h3 id="第一种方法-非立即执行">第一种方法 - 非立即执行</h3>
<p>通过定时器限定多久执行一次</p>
<pre><code class="language-js">   let flag = true
      window.onscroll = ()=&gt; {
        if(flag) {
          setTimeout(()=&gt; {
            console.log(&quot;Hello world&quot;);
            flag = true
          },500)
        }
        flag = false
      }
</code></pre>
<h3 id="函数优化">函数优化</h3>
<p>优化方法与防抖函数的优化相同</p>
<pre><code class="language-js"> window.onscroll = throttle(function(){
      console.log(this.value);
    },500)
    function throttle(fn, delayTime) {
      let flag = true
      return function () {
        if (flag) {
          setTimeout(() =&gt; {
            fn()
            flag = true
          }, delayTime)
        }
        flag = false
      }
    }
</code></pre>
<h3 id="第二种方法-立即执行">第二种方法 - 立即执行</h3>
<pre><code class="language-js">    function throttle(fn, delayTime) {
      let flag = true
      return function () {
        if (flag) {
          setTimeout(() =&gt; {
            fn()
            flag = true
          }, delayTime)
        }
        flag = false
      }
    }
</code></pre>
<h3 id="第三种方法-时间戳版本">第三种方法 - 时间戳版本</h3>
<p>创建时间戳，在时间戳内，函数只执行一次</p>
<pre><code class="language-js">    window.onscroll = throttle(function(){
      console.log(&quot;Hello world!&quot;);
    },1000)
    function throttle(fn, delayTime) {
      let pre = 0
      return function(){
        let now = Date.now()
        if(now-pre&gt;delayTime) {
          fn.call(this)
          pre = now
        }
      }
    }
</code></pre>
<h1 id="总结">总结</h1>
<ul>
<li>相同点
<ul>
<li>防抖与节流都是为了防止函数在短时间内被频繁的触发</li>
</ul>
</li>
<li>不同点
<ul>
<li>防抖函数只执行最后一次的操作，类似游戏中的回城，在回城期间，进行操作会打断回城<br>
<img src="https://mlmc12138.github.io/post-images/1644675406390.gif" alt="" loading="lazy"></li>
<li>节流类似将多个操作合并为一个，类似于游戏中的技能释放，释放后技能会进入CD，CD完成后才能再次进行施法<br>
<img src="https://mlmc12138.github.io/post-images/1644675346108.gif" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂记]]></title>
        <id>https://mlmc12138.github.io/post/za-ji/</id>
        <link href="https://mlmc12138.github.io/post/za-ji/">
        </link>
        <updated>2022-02-10T14:04:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>分享我喜欢的歌手 房东的猫 浪漫才子-吴佩玲 人间理想-王心怡</p>
<!-- more -->
<p><img src="https://mlmc12138.github.io/post-images/1644503847765.png" alt="" loading="lazy"><br>
<img src="https://mlmc12138.github.io/post-images/1644503877133.png" alt="" loading="lazy"></p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://mlmc12138.github.io/post/er-fen-cha-zhao/</id>
        <link href="https://mlmc12138.github.io/post/er-fen-cha-zhao/">
        </link>
        <updated>2022-02-09T12:32:21.000Z</updated>
        <content type="html"><![CDATA[<p>二分查找是非常经典的算法；虽然不复杂，但是有很多细节在里面；要做到看到能使用二分的题立刻想出思路</p>
<h3 id="核心代码">核心代码</h3>
<pre><code class="language-js">var search = function(nums, target) {
  let sum = 0
  let left = 0
  let right = nums.length-1
  while(left&lt;=right) {
    let mid = (left +(right-left))&gt;&gt;1
    if(nums[mid]==target) {
       return mid
    } else if(nums[mid&gt;target]) {
      right = mid - 1
    } else if(nums[mid]&lt;target) {
      left = mid + 1
    }
  }
};
</code></pre>
<p>值得注意的点就是 while循环里的 条件是 left &lt; right 还是 left &lt;= right；以及 mid是+1还是-1的问题</p>
<h2 id="为什么-while-循环的条件中是-而不是">为什么 while 循环的条件中是 &lt;=，而不是 &lt;？</h2>
<p>因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。<br>
这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。<br>
我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。<br>
while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p>while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [2, 2]，这时候区非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<h2 id="为什么-left-mid-1right-mid-1我看有的代码是-right-mid-或者-left-mid没有这些加加减减到底怎么回事怎么判断">为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？</h2>
<p>当发现索引 mid 不是要找的 target 时，下一步应该去搜索 [left, mid-1] 或者 [mid+1, right]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单链表题目]]></title>
        <id>https://mlmc12138.github.io/post/dan-lian-biao-ti-mu/</id>
        <link href="https://mlmc12138.github.io/post/dan-lian-biao-ti-mu/">
        </link>
        <updated>2022-02-06T12:20:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="合并两个有序单链表">合并两个有序单链表：</h3>
<p>​        题目链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/</p>
<p>​        思路：比较两个链表的值，将值较小的加入到结果链表中</p>
<p>​		代码：</p>
<pre><code class="language-js">var mergeTwoLists = function(list1, list2) {
  if(list1===null) {
    return list2
  }
  if(list2===null) {
    return list1
  }
  if(list1.val&lt;list2.val) {
    list1.next = mergeTwoLists(list1.next,list2)
    return list1
  }
  else {
    list2.next = mergeTwoLists(list1,list2.next)
    return list2
  }
};
</code></pre>
<h3 id="环形链表">环形链表</h3>
<p>​		题目地址：https://leetcode-cn.com/problems/linked-list-cycle/</p>
<p>​		思路：通过快慢指针进行判断，快指针一次走两步，慢指针一次走一步，若链表中存在环，则两指针一定会有重合的时候</p>
<p>​		代码：</p>
<pre><code class="language-js">var hasCycle = function(head) {
    let left = head
    let right = head
    while(right!=null&amp;&amp;right.next!=null) {
      left = left.next
      right = right.next.next
      if(left==right) {
        return true
      }
    }
    return false
};
</code></pre>
<h3 id="链表的中间节点">链表的中间节点</h3>
<p>​			题目地址： https://leetcode-cn.com/problems/middle-of-the-linked-list/</p>
<p>​			思路： 通过快慢指针进行判断，指针运动方式 慢指针一次一步 快指针一次两步 这样当快指针到达尾部时，慢指针所在的位置就是链表的中点</p>
<p>​			代码</p>
<pre><code class="language-js">var middleNode = function(head) {
    let slow =  head
    let fast = head
    while(fast&amp;&amp;fast.next) {
        fast = fast.next.next
        slow = slow.next
    }
    return slow
};
</code></pre>
<h3 id="删除单链表的倒数第k个元素">删除单链表的倒数第k个元素</h3>
<p>​			题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</p>
<p>​			思路： 也是通过快慢指针；要删除倒数第k个元素即要从前向后走 n-k 步 （n为链表长度） 让两指针相距k，当快指针走到最后时，慢指针的next即为倒数第k个元素</p>
<p>​			代码：</p>
<pre><code class="language-js"> var removeNthFromEnd = function (head, n) {
      var left = head
      var right = head
      while(n&gt;0) {
        right = right.next
        n--
      }
      if(!right) return head.next
      while(right&amp;&amp;right.next) {
        left = left.next
        right = right.next
      }
      left.next = left.next.next
      return head
    };
</code></pre>
<p>这些都是比较经典的单链表相关的问题，大部分题目都是使用双指针去解决的；在做题时一定要灵活运用双指针</p>
]]></content>
    </entry>
</feed>